# 队列

## 定义

**队列** (Queue) 是一种限定性的有序线性表，它只允许在表的一端插入元素，而在另一端删除元素，所以队列具有先进先出 (Fist In Fist Out，缩写为**FIFO**)的特性。

1. 在队列中，允许插入的一端叫做**队尾**(rear)；
2. 允许删除的一端则称为**队头**(front)。
3. 队列是一个**有序列表**，可以用**数组**或是**链表**来实现。
4. 遵循**先进先出**的原则。即:先存入队列的数据，要先取出。

### 抽象数据类型

**数据元素**：可以是任意类型的数据，但必须属于同一个数据对象。

**关系**：队列中数据元素之间是线性关系。

**基本操作:**

1. 初始化操作。使用构造方法设置一个空队列。
2. isEmpty():判空操作。若队列为空，则返回TRUE，否则返回FALSE。
3. isFull():判满操作。若队列为满,则返回TRUE，否则返回FALSE。
4. getSize():获取队列元素个数。
5. add(E e):进队操作。在队列Q的队尾插入e。如果队满，抛出异常。
6. poll():出队操作。使队列Q的队头元素出队，并用e返回其值。如果队空，抛出异常。
7. getHead ():取队头元素操作。用e取得队头元素的值。如果队列为空，则返回null。
8. clear():队列置空操作。将队列Q置为空队列。
9. destroy():队列销毁操作。释放队列的空间。

## 顺序存储

>  队列的一种顺序存储称为顺序队列。与顺序栈类似，在队列的顺序存储结构中，用一组地址连续的存储单元依次存放从队头到队尾的元素，如一维数组Queue[maxSize]。

### 数组队列

由于队列中队头和队尾的位置都是动态变化的，因此需要附设两个指针 front和 rear。

- front：指示队头元素在数组中的位置;
- rear：指示真实队尾元素相邻的下一个位置。

#### 思路分析

- 初始化队列时，令`front = rear = 0`。
- 判断队空的条件：`front == rear`。
- 判断队满的条件：`rear == maxSize`。
- 入队时，若尾指针rear 小于队列的最大下标 `maxSize`,则将数据存入rear所指的数组元素中,否则无法存入数据；然后将尾指针往后移: `rear + 1`。
- 出队时，若队列不为空，取出队头指针front所指的元素；然后将尾指针往后移: `front + 1`。

#### 代码实现

定义接口方法：

参看：[Queue.java](./Queue.java)

数组队列实现：

参看：[ArrayQueue.java](./impl/ArrayQueue.java)

#### 分析

##### 假溢出现象

在非空顺序队列中，队头指针始终指向当前的队头元素，而队尾指针始终指向真正队尾元素。当`rear == maxSize - 1` 时，认为队满。但此时不一定是真的队满，因为随着部分元素的出队，数组前面会出现一些空单元，如下图所示。由于只能在队尾入队，使得上述空单元无法使用。把这种现象称为**假溢出**。

<img src="https://gitee.com/koala010/typora/raw/master/img/image-20210529183259424.png" alt="image-20210529183259424" style="zoom: 80%;" />

问题：目前这个数组使用一次就不能用（出队的空间），没有达到复用的效果。可使用算法将其改造成环形队列（取模：%）。

### 环形队列

> 为了解决假溢出现象并使得队列空间得到充分利用,一个较巧妙的办法是将顺序队列的数组看成一个环状的空间，即规定最后一个单元的后继为第一个单元，我们形象地称之为循环队列。

#### 思路分析

- 初始化队列时，令`front = rear = 0`。`front`指向队列的第一个元素，`rear`指向队列最后一个元素的后一个位置（希望损失一个位置作为约定，用来区分队空和队满）。
- 判断队空的条件：`front == rear`。
- 判断队满的条件：`(rear + 1) % maxSize == front`。
- 队列中的元素个数：`(rear + maxSize - front) % maxSize`。
- 入队时，将数据存入`rear`所指的数组元素中，指针变化：`rear = ( rear+1) % maxSize `。
- 出队时，将数据存入`front`所指的数组元素中，指针变化：`front = ( front+1 )  % maxSize`。

下图给出了循环队列的几种情况：

<img src="https://gitee.com/koala010/typora/raw/master/img/循环队列示意图.png" alt="image-20210530163134963" style="zoom:80%;" />

#### 代码实现

参看：[LoopQueue.java](./impl/LoopQueue.java)

#### 分析

相比数组队列来说，循环队列解决了**数组空间不能再次利用**的问题。但依然存在一些问题：

- **当队列真的满的时候就不能再进行入队操作了**。但是从我们常用的`ArrayList`来分析，在存储空间允许的条件下是可以一直添加元素的。
- **当数组元素频繁进行入队或者出队操作时，可能造成空间的浪费**。循环队列其实只利用了有限的存储空间，但是在最初实例化循环队列的时候，如果空间声明的很大，那么会造成一定程度上的空间浪费。
  - *假设，声明一个容量为20的循环队列，但每次入队2个元素后，又出队2个元素，那么实际只利用了很有限的空间，造成了空间浪费，但又不能声明的空间太小，并不能保证未来每次只入队或者出队2个元素。*

因此，是否可以实现动态的将循环队列进行扩容或者缩容，上述两个问题，可以利用下面的==动态循环队列==来实现。

*当然，上述的数组队列，也可以改造成动态的，但是出队元素的空间依然会浪费，所以没必要进行实现。*



### 动态循环队列

> 为了解决循环队列，队满不能入队，以及频繁入队出队引起的空间浪费，而引出动态循环队列的概念。即**在队满时进行扩容，在队列元素个数下降到一定情况下进行缩容**。

#### 思路分析

- 除了入队和出队操作，其他操作均与循环队列相同。
- 循环队列存储元素的数组容量变更思路：使用==扩容一倍/缩容一倍==的新数组接收原来循环队列存储的元素。接收后，将`front`指针置为0；将`rear`指针值到最后一个元素的位置（即存储有效元素的数量）。
- 什么时候扩容：队满
- 什么时候缩容：队列元素只有1/4，并且缩容后容量不为0。
  - 数组容量为0时，缩容会出现异常
  - 为什么不在队列元素只有1/2时缩容？**当数组元素为一半的时候一次添加，一次删除，造成的一直扩容和减小的操作**。

#### 代码实现

参看：[DynamicLoopQueue.java](./impl/DynamicLoopQueue.java)

## 总结指针变化

|          | 简单队列         | 循环队列                           |
| -------- | ---------------- | ---------------------------------- |
| 初始     | front = rear = 0 | front = rear = 0                   |
| 判空     | front = rear     | front = rear                       |
| 判满     | rear = maxSize   | (rear + 1) % maxSize = front       |
| 入队     | rear + 1         | (rear + 1) % maxSize               |
| 出队     | front+ 1         | (front+ 1) % maxSize               |
| 元素个数 | rear - front +1  | (rear + maxSize - front) % maxSize |

- `front`：指示队头元素在数组中的位置。
- `rear`：指示真实队尾元素相邻的下一个位置。
- `maxSize`：存储元素 数组的长度。
